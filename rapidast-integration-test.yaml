apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: cma-rapidast-integration-test
spec:
  description: |
    Integration test that provisions an ephemeral Hypershift cluster, deploys the
    Custom Metrics Autoscaler Operator bundle from a Konflux snapshot, and runs
    RapiDAST security scanning against the operator endpoints.
  params:
  - description: Snapshot of the application containing the operator bundle
    name: SNAPSHOT
    type: string
  - description: Namespace where the operator bundle will be deployed
    name: NAMESPACE
    default: openshift-keda
    type: string
  - description: Duration to wait for bundle installation to complete before failing
    name: INSTALL_TIMEOUT
    default: 10m
    type: string
  tasks:
  - name: extract-bundle-image
    taskSpec:
      params:
      - name: SNAPSHOT
        type: string
      results:
      - name: bundle-image
        description: Bundle image extracted from snapshot
      steps:
      - name: extract-image
        image: quay.io/konflux-ci/konflux-test:latest
        env:
        - name: SNAPSHOT
          value: "$(params.SNAPSHOT)"
        script: |
          #!/bin/bash
          set -euxo pipefail
          echo "Extracting bundle image from snapshot..."
          BUNDLE_IMAGE=$(echo "$SNAPSHOT" | jq -r '(.spec.components[]? // .components[]?) | select(.name | test(".*bundle.*"; "i")) | .containerImage' | head -1)
          if [ -z "$BUNDLE_IMAGE" ] || [ "$BUNDLE_IMAGE" = "null" ]; then
            BUNDLE_IMAGE=$(echo "$SNAPSHOT" | jq -r '(.spec.components[]? // .components[]?) | select(.name == "custom-metrics-autoscaler-operator-bundle") | .containerImage')
          fi
          if [ -z "$BUNDLE_IMAGE" ] || [ "$BUNDLE_IMAGE" = "null" ]; then
            echo "ERROR: No bundle image found"
            echo "Available components:"
            echo "$SNAPSHOT" | jq -r '(.spec.components[]? // .components[]?)?.name' | sed 's/^/  - /'
            exit 1
          fi
          echo "Found bundle image: $BUNDLE_IMAGE"
          echo -n "$BUNDLE_IMAGE" | tee "$(results.bundle-image.path)"
    params:
    - name: SNAPSHOT
      value: $(params.SNAPSHOT)
  - name: provision-eaas-space
    runAfter:
    - extract-bundle-image
    taskRef:
      resolver: git
      params:
      - name: url
        value: https://github.com/konflux-ci/build-definitions.git
      - name: revision
        value: main
      - name: pathInRepo
        value: task/eaas-provision-space/0.1/eaas-provision-space.yaml
    params:
    - name: ownerName
      value: $(context.pipelineRun.name)
    - name: ownerUid
      value: $(context.pipelineRun.uid)
  - name: provision-cluster
    runAfter:
    - provision-eaas-space
    taskSpec:
      results:
      - name: clusterName
        value: "$(steps.create-cluster.results.clusterName)"
      steps:
      - name: get-supported-versions
        ref:
          resolver: git
          params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: stepactions/eaas-get-supported-ephemeral-cluster-versions/0.1/eaas-get-supported-ephemeral-cluster-versions.yaml
        params:
        - name: eaasSpaceSecretRef
          value: $(tasks.provision-eaas-space.results.secretRef)
      - name: pick-version
        ref:
          resolver: git
          params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: stepactions/eaas-get-latest-openshift-version-by-prefix/0.1/eaas-get-latest-openshift-version-by-prefix.yaml
        params:
        - name: prefix
          value: "$(steps.get-supported-versions.results.versions[0])."
      - name: create-cluster
        ref:
          resolver: git
          params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: stepactions/eaas-create-ephemeral-cluster-hypershift-aws/0.1/eaas-create-ephemeral-cluster-hypershift-aws.yaml
        params:
        - name: eaasSpaceSecretRef
          value: $(tasks.provision-eaas-space.results.secretRef)
        - name: version
          value: "$(steps.pick-version.results.version)"
  - name: deploy-operator
    runAfter:
    - provision-cluster
    params:
    - name: bundleImage
      value: "$(tasks.extract-bundle-image.results.bundle-image)"
    - name: namespace
      value: "$(params.NAMESPACE)"
    - name: installTimeout
      value: "$(params.INSTALL_TIMEOUT)"
    taskSpec:
      params:
      - name: bundleImage
        type: string
      - name: namespace
        type: string
      - name: installTimeout
        type: string
      volumes:
      - name: credentials
        emptyDir: {}
      steps:
      - name: get-kubeconfig
        ref:
          resolver: git
          params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: stepactions/eaas-get-ephemeral-cluster-credentials/0.1/eaas-get-ephemeral-cluster-credentials.yaml
        params:
        - name: eaasSpaceSecretRef
          value: $(tasks.provision-eaas-space.results.secretRef)
        - name: clusterName
          value: "$(tasks.provision-cluster.results.clusterName)"
        - name: credentials
          value: credentials
      - name: create-namespace
        image: quay.io/jkyros/kubectl:latest
        env:
        - name: KUBECONFIG
          value: "/credentials/$(steps.get-kubeconfig.results.kubeconfig)"
        - name: NAMESPACE
          value: "$(params.namespace)"
        volumeMounts:
        - name: credentials
          mountPath: /credentials
        script: |
          #!/bin/bash
          set -euxo pipefail
          echo "Creating namespace: $NAMESPACE"
          kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespace $NAMESPACE is ready"
      - name: operator-sdk-run-bundle
        image: quay.io/operator-framework/operator-sdk:latest
        env:
        - name: KUBECONFIG
          value: "/credentials/$(steps.get-kubeconfig.results.kubeconfig)"
        - name: NAMESPACE
          value: "$(params.namespace)"
        volumeMounts:
        - name: credentials
          mountPath: /credentials
        script: |
          #!/bin/bash
          set -euo pipefail
          
          echo "Starting operator bundle installation..."
          echo "Bundle: $(params.bundleImage)"
          echo "Namespace: $NAMESPACE"
          echo "Timeout: $(params.installTimeout)"
          
          # Function to capture debugging information
          capture_debug_info() {
            echo "=========================================="
            echo "DEBUGGING INFORMATION - OPERATOR INSTALLATION FAILED"
            echo "=========================================="
            
            echo "=== NAMESPACE STATUS ==="
            kubectl get namespace "$NAMESPACE" -o yaml || true
            
            echo "=== DEPLOYMENTS ==="
            kubectl get deployments -n "$NAMESPACE" -o wide || true
            
            echo "=== PODS ==="
            kubectl get pods -n "$NAMESPACE" -o wide || true
            
            echo "=== EVENTS ==="
            kubectl get events -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp || true
            
            echo "=== CSVS ==="
            kubectl get csv -n "$NAMESPACE" -o wide || true
            
            echo "=== SUBSCRIPTIONS ==="
            kubectl get subscriptions -n "$NAMESPACE" -o wide || true
            
            echo "=== CATALOG SOURCES ==="
            kubectl get catalogsources -n "$NAMESPACE" -o wide || true
            
            echo "=== OPERATOR GROUPS ==="
            kubectl get operatorgroups -n "$NAMESPACE" -o wide || true
            
            echo "=== INSTALL PLANS ==="
            kubectl get installplans -n "$NAMESPACE" -o wide || true
            
            # Get detailed status of any failed pods
            echo "=== FAILED POD DETAILS ==="
            for pod in $(kubectl get pods -n "$NAMESPACE" --field-selector=status.phase=Failed -o name 2>/dev/null || true); do
              echo "--- Pod: $pod ---"
              kubectl describe "$pod" -n "$NAMESPACE" || true
              echo "--- Pod Logs: $pod ---"
              kubectl logs "$pod" -n "$NAMESPACE" --previous=true || true
              kubectl logs "$pod" -n "$NAMESPACE" || true
            done
            
            # Get details of pods that are not running
            echo "=== NON-RUNNING POD DETAILS ==="
            for pod in $(kubectl get pods -n "$NAMESPACE" --field-selector=status.phase!=Running,status.phase!=Succeeded -o name 2>/dev/null || true); do
              echo "--- Pod: $pod ---"
              kubectl describe "$pod" -n "$NAMESPACE" || true
              echo "--- Pod Logs: $pod ---"
              kubectl logs "$pod" -n "$NAMESPACE" --previous=true || true
              kubectl logs "$pod" -n "$NAMESPACE" || true
            done
            
            # Get CSV details if they exist
            echo "=== CSV DETAILS ==="
            for csv in $(kubectl get csv -n "$NAMESPACE" -o name 2>/dev/null || true); do
              echo "--- CSV: $csv ---"
              kubectl describe "$csv" -n "$NAMESPACE" || true
              kubectl get "$csv" -n "$NAMESPACE" -o yaml || true
            done
            
            echo "=========================================="
            echo "END DEBUGGING INFORMATION"
            echo "=========================================="
          }
          
          # Set up trap to capture debug info on failure
          trap 'capture_debug_info' ERR
          
          # Run operator-sdk with explicit error handling
          if ! operator-sdk run bundle \
            --security-context-config restricted \
            --namespace "$NAMESPACE" \
            --timeout "$(params.installTimeout)" \
            "$(params.bundleImage)"; then
            
            echo "ERROR: operator-sdk run bundle failed"
            capture_debug_info
            exit 1
          fi
          
          echo "Operator bundle installation completed successfully!"
  - name: configure-keda
    runAfter:
    - deploy-operator
    taskSpec:
      params:
      - name: namespace
        type: string
      volumes:
      - name: credentials
        emptyDir: {}
      steps:
      - name: get-kubeconfig
        ref:
          resolver: git
          params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: stepactions/eaas-get-ephemeral-cluster-credentials/0.1/eaas-get-ephemeral-cluster-credentials.yaml
        params:
        - name: eaasSpaceSecretRef
          value: $(tasks.provision-eaas-space.results.secretRef)
        - name: clusterName
          value: "$(tasks.provision-cluster.results.clusterName)"
        - name: credentials
          value: credentials
      - name: create-kedacontroller
        image: quay.io/konflux-ci/konflux-test:latest
        env:
        - name: KUBECONFIG
          value: "/credentials/$(steps.get-kubeconfig.results.kubeconfig)"
        - name: NAMESPACE
          value: "$(params.namespace)"
        volumeMounts:
        - name: credentials
          mountPath: /credentials
        script: |
          #!/bin/bash
          set -euxo pipefail
          echo "Creating KedaController instance in namespace: $NAMESPACE"
          oc apply -f - <<EOF
          apiVersion: keda.sh/v1alpha1
          kind: KedaController
          metadata:
            name: keda
            namespace: $NAMESPACE
          spec:
            metricsServer:
              logLevel: "0"
            operator:
              logEncoder: console
              logLevel: info
            serviceAccount: {}
            watchNamespace: ""
          EOF
          echo "Waiting for KEDA components to be ready..."
          timeout 300s bash -c "
            until [ \"\$(oc get deployment -n $NAMESPACE keda-metrics-apiserver -o jsonpath='{.status.conditions[?(@.type==\"Available\")].status}' 2>/dev/null)\" = \"True\" ]; do
              echo -n .
              sleep 5
            done
          "
          echo " keda-metrics-apiserver ready"
          timeout 300s bash -c "
            until [ \"\$(oc get deployment -n $NAMESPACE keda-operator -o jsonpath='{.status.conditions[?(@.type==\"Available\")].status}' 2>/dev/null)\" = \"True\" ]; do
              echo -n .
              sleep 5
            done
          "
          echo " keda-operator ready"
          echo "Custom Metrics Autoscaler Operator is ready!"
    params:
    - name: namespace
      value: "$(params.NAMESPACE)"
  - name: rapidast-check
    runAfter:
    - configure-keda
    taskRef:
      resolver: git
      params:
      - name: url
        value: https://github.com/redhatproductsecurity/rapidast
      - name: revision
        value: development
      - name: pathInRepo
        value: examples/konflux/rapidast-check.yaml
    params:
    - name: KUBECONFIG_SECRET
      value: "$(tasks.provision-eaas-space.results.secretRef)"
    - name: PORT_FORWARD_TARGETS
      value: "service/keda-metrics-apiserver -n $(params.NAMESPACE) 9443:9443,service/keda-operator-metrics-service -n $(params.NAMESPACE) 8080:8080"
    - name: RAPIDAST_CONFIG_VALUE
      value: |
        config:
          configVersion: 6
          results:
            exclusions:
              rules:
                - name: "Exclude findings below a severity level of Important"
                  cel_expression: ".result.level != 'error' && .result.level != 'warning'"
        application:
          shortName: "custom-metrics-autoscaler-operator"
          url: "https://127.0.0.1:9443"
        scanners:
          zap:
            spider:
              maxDuration: 5
            passiveScan:
              maxDuration: 10
            activeScan:
              policy: API-scan-minimal
              maxDuration: 10
